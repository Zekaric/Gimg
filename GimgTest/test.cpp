#include "pch.h"

/**************************************************************************************************
prototype:
**************************************************************************************************/

/**************************************************************************************************
test: libraryStart
**************************************************************************************************/
TEST(Gimg, LibraryStart)
{
   EXPECT_TRUE(grlStart());
   EXPECT_TRUE(gimgStart());

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: Cloc
**************************************************************************************************/
TEST(Gimg, Cloc)
{
   Gimg     *img;
   Gindex    pixelIndex;
   Gcount    pixelCount;
   Gn1      *data,
             k;

   grlStart();
   gimgStart();

   img = gimgCloc(gimgTypeRGBA_N1, 8, 8);
   EXPECT_TRUE(img != nullptr);

   EXPECT_TRUE(img->width           == 8);
   EXPECT_TRUE(img->height          == 8);
   EXPECT_TRUE(img->valueType       == gimgTypeRGBA_N1);
   EXPECT_TRUE(img->valueByteCount  == 4);
   EXPECT_TRUE(img->rowByteCount    == 8 * 4);

   data       = img->valueData;
   pixelCount = 8 * 8;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);
      EXPECT_TRUE(k == 0);

      data += img->valueByteCount;
   }

   gimgDloc(img);

   img = gimgCloc(gimgTypeRGB_N1, 8, 8);
   EXPECT_TRUE(img != nullptr);

   EXPECT_TRUE(img->valueByteCount  == 3);
   EXPECT_TRUE(img->rowByteCount    == 8 * 3);

   data = img->valueData;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);
      EXPECT_TRUE(k == 0);

      data += img->valueByteCount;
   }

   gimgDloc(img);

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: SetCircle
**************************************************************************************************/
TEST(Gimg, SetCircle)
{
   Gimg     *img;
   Gindex    //radius,
             pixelIndex;
   Gcount    pixelCount;
   GimgValue color;
   Gn1      *data,
             k,
             kResult[16 * 16] =
   {
      0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
      0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
   };

   grlStart();
   gimgStart();

   gmemClearType(&color, GimgValue);

   img = gimgCloc(gimgTypeK_N1, 16, 16);

#if 0
   // Manual test.
   //forCount(radius, 32)
   radius = 16;
   {
      // Set the background to white.
      gimgValueSET_K_N1_WHITE(color);
      gimgSetClear(img, color);

      // Set the edges to black.
      gimgValueSET_K_N1_BLACK(color);
      gimgSetCircle(img, 0, 0, radius, color);
   }
#else
   // Set the background to white.
   gimgValueSET_K_N1_WHITE(color);
   gimgSetClear(img, color);

   // Set the edges to black.
   gimgValueSET_K_N1_BLACK(color);
   gimgSetCircle(img, 0, 0, 16, color);

   data       = img->valueData;
   pixelCount = 16 * 16;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);

      EXPECT_TRUE(k == kResult[pixelIndex]);

      data += img->valueByteCount;
   }
#endif

   gimgDloc(img);

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: SetCircleFill
**************************************************************************************************/
TEST(Gimg, SetCircleFill)
{
   Gimg     *img;
   Gindex    //radius,
             pixelIndex;
   Gcount    pixelCount;
   GimgValue color;
   Gn1      *data,
             k,
             kResult[16 * 16] =
   {
      0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
   };

   grlStart();
   gimgStart();

   gmemClearType(&color, GimgValue);

   img = gimgCloc(gimgTypeK_N1, 16, 16);

#if 0
   // Manual test.
   forCount(radius, 32)
   {
      // Set the background to white.
      gimgValueSET_K_N1_WHITE(color);
      gimgSetClear(img, color);

      // Set the filled circle black
      gimgValueSET_K_N1_BLACK(color);
      gimgSetCircleFill(img, 0, 0, radius, color);

      gimgValueSET_K_N1_GRAYDARK(color);
      gimgSetCircle(img, 0, 0, radius, color);
   }
#else
   // Set the background to white.
   gimgValueSET_K_N1_WHITE(color);
   gimgSetClear(img, color);

   // Set the filled circle black
   gimgValueSET_K_N1_BLACK(color);
   gimgSetCircleFill(img, 0, 0, 16, color);

   data       = img->valueData;
   pixelCount = 16 * 16;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);

      EXPECT_TRUE(k == kResult[pixelIndex]);

      data += img->valueByteCount;
   }
#endif

   gimgDloc(img);

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: SetImage
**************************************************************************************************/
TEST(Gimg, SetImage)
{
   Gimg     *imgCircle,
            *imgRect,
            *imgResult;
   Gindex    pixelIndex;
   Gcount    pixelCount;
   GimgValue color;
   Gn1      *data,
             k,
             kResult[16 * 16] =
   {
      0xff, 0xff, 0xff, 0xff, 0xff, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0xff, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xff, 0xff, 0xff, 0xff,
      0xff, 0xff, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0xff, 0xff,
      0xff, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xff, 0xff,
      0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0xff,
      0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
      0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
      0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
      0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
      0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0xff, 0xff, 0xff, 0xff, 0xff, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   };

   grlStart();
   gimgStart();

   gmemClearType(&color, GimgValue);

   imgCircle = gimgCloc(gimgTypeK_N1, 16, 16);
   imgRect   = gimgCloc(gimgTypeK_N1, 16, 16);

   // Set the background to white.
   gimgValueSET_K_N1_WHITE(color);
   gimgSetClear(imgCircle, color);
   gimgSetClear(imgRect,   color);

   // Set the filled circle black
   gimgValueSET_K_N1_BLACK(color);
   gimgSetCircleFill(imgCircle, 0, 0, 16,     color);
   gimgSetRectFill(  imgRect,   0, 0, 16, 16, color);

   // Set a perimeter to dark gray
   gimgValueSET_KA_N1_GRAYDARK(color);
   gimgSetCircle(imgCircle, 0, 0, 16,     color);
   gimgSetRect(  imgRect,   0, 0, 16, 16, color);

   // Copy the rectangle over the circle.
   imgResult = gimgClocClone(imgCircle);
   gimgSetImage(imgResult, 8, 8, imgRect);

   data       = imgResult->valueData;
   pixelCount = 16 * 16;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);

      EXPECT_TRUE(k == kResult[pixelIndex]);

      data += imgResult->valueByteCount;
   }

   gimgDloc(imgResult);
   gimgDloc(imgRect);
   gimgDloc(imgCircle);

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: SetClear
**************************************************************************************************/
TEST(Gimg, SetClear)
{
   Gimg     *img;
   Gindex    pixelIndex;
   Gcount    pixelCount;
   GimgValue color;
   Gn1      *data,
             k;

   grlStart();
   gimgStart();

   gmemClearType(&color, GimgValue);

   img = gimgCloc(gimgTypeK_N1, 8, 8);

   gimgValueSET_K_N1_WHITE(color);
   gimgSetClear(img, color);

   data       = img->valueData;
   pixelCount = 8 * 8;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);
      EXPECT_TRUE(k == 255);

      data += img->valueByteCount;
   }

   gimgDloc(img);

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: SetLineHAndV
**************************************************************************************************/
TEST(Gimg, SetLineHAndV)
{
   Gimg     *img;
   Gindex    pixelIndex;
   Gcount    pixelCount;
   GimgValue color;
   Gn1      *data,
             k;

   grlStart();
   gimgStart();

   gmemClearType(&color, GimgValue);

   img = gimgCloc(gimgTypeK_N1, 8, 8);

   // Set the background to white.
   gimgValueSET_K_N1_WHITE(color);
   gimgSetClear(img, color);

   // Set the edges to black.
   gimgValueSET_K_N1_BLACK(color);
   gimgSetLineH(img, 0, 0, 8, color);
   gimgSetLineV(img, 0, 0, 8, color);
   gimgSetLineH(img, 0, 7, 8, color);
   gimgSetLineV(img, 7, 0, 8, color);

   data       = img->valueData;
   pixelCount = 8 * 8;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);

      if (pixelIndex % 8 == 0 ||
          pixelIndex % 8 == 7 ||
          pixelIndex / 8 == 0 ||
          pixelIndex / 8 == 7)
      {
         EXPECT_TRUE(k == 0);
      }
      else
      {
         EXPECT_TRUE(k == 255);
      }

      data += img->valueByteCount;
   }

   gimgDloc(img);

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: SetRect
**************************************************************************************************/
TEST(Gimg, SetRect)
{
   Gimg     *img;
   Gindex    pixelIndex;
   Gcount    pixelCount;
   GimgValue color;
   Gn1      *data,
             k,
             kResult[16 * 16] =
   {
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   };

   grlStart();
   gimgStart();

   gmemClearType(&color, GimgValue);

   img = gimgCloc(gimgTypeK_N1, 16, 16);

   // Set the background to white.
   gimgValueSET_K_N1_WHITE(color);
   gimgSetClear(img, color);

   // Set the edges to black.
   gimgValueSET_K_N1_BLACK(color);
   gimgSetRect(img, 1, 1, 14, 14, color);

   data       = img->valueData;
   pixelCount = 16 * 16;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);

      EXPECT_TRUE(k == kResult[pixelIndex]);

      data += img->valueByteCount;
   }

   gimgDloc(img);

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: SetRectFill
**************************************************************************************************/
TEST(Gimg, SetRectFill)
{
   Gimg     *img;
   Gindex    pixelIndex;
   Gcount    pixelCount;
   GimgValue color;
   Gn1      *data,
             k,
             kResult[16 * 16] =
   {
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
   };

   grlStart();
   gimgStart();

   gmemClearType(&color, GimgValue);

   img = gimgCloc(gimgTypeK_N1, 16, 16);

   // Set the background to white.
   gimgValueSET_K_N1_WHITE(color);
   gimgSetClear(img, color);

   // Set the filled circle black
   gimgValueSET_K_N1_BLACK(color);
   gimgSetRectFill(img, 1, 1, 14, 14, color);

   data       = img->valueData;
   pixelCount = 16 * 16;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);

      EXPECT_TRUE(k == kResult[pixelIndex]);

      data += img->valueByteCount;
   }

   gimgDloc(img);

   gimgStop();
   grlStop();
}

/**************************************************************************************************
test: SetResizeFixed_1
**************************************************************************************************/
TEST(Gimg, SetResizeFixed_1)
{
   Gimg     *imgCircle,
            *imgResult;
   Gindex    pixelIndex;
   Gcount    pixelCount;
   GimgValue color;
   Gn1      *data,
             k,
             kResult[8 * 8] =
   {
      0xff, 0xbf, 0x3f, 0x00, 0x00, 0x7f, 0xff, 0xff,
      0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff,
      0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbf,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f,
      0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
      0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xbf, 0xff,
      0xff, 0xff, 0xbf, 0x7f, 0x7f, 0xff, 0xff, 0xff,
   };

   grlStart();
   gimgStart();

   gmemClearType(&color, GimgValue);

   imgCircle = gimgCloc(gimgTypeK_N1, 16, 16);
   imgResult = gimgCloc(gimgTypeK_N1, 8, 8);

   // Set the background to white.
   gimgValueSET_K_N1_WHITE(color);
   gimgSetClear(imgCircle, color);

   // Set the filled circle black
   gimgValueSET_K_N1_BLACK(color);
   gimgSetCircleFill(imgCircle, 0, 0, 15, color);

   // Copy the rectangle over the circle.
   gimgSetResizeFixed_1(imgResult, imgCircle);

   data       = imgResult->valueData;
   pixelCount = 8 * 8;
   forCount(pixelIndex, pixelCount)
   {
      gimgValueGET_K_N1(*((GimgValue *) data), k);

      EXPECT_TRUE(k == kResult[pixelIndex]);

      data += imgResult->valueByteCount;
   }

   gimgDloc(imgResult);
   gimgDloc(imgCircle);

   gimgStop();
   grlStop();
}
